(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{427:function(e,s,_){"use strict";_.r(s);var t=_(2),i=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"redis数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构"}},[e._v("#")]),e._v(" Redis数据结构")]),e._v(" "),s("blockquote",[s("p",[e._v("Redis 数据类型以及使用场景分别是什么？")])]),e._v(" "),s("p",[e._v("Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9bba8c27eb94f08abde5d7473647c47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=392&s=102469&e=png&b=fbfafa",alt:"image.png"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b9ac861cbbd41d3b963202c40922230~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1500&h=600&s=451397&e=png&b=ffffff",alt:"image.png"}})]),e._v(" "),s("p",[e._v("随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。 Redis 五种数据类型的应用场景：")]),e._v(" "),s("ul",[s("li",[e._v("String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。")]),e._v(" "),s("li",[e._v("List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。")]),e._v(" "),s("li",[e._v("Hash 类型：缓存对象、购物车等。")]),e._v(" "),s("li",[e._v("Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。")]),e._v(" "),s("li",[e._v("Zset 类型：排序场景，比如排行榜、电话和姓名排序等。")])]),e._v(" "),s("p",[e._v("Redis 后续版本又支持四种数据类型，它们的应用场景如下：")]),e._v(" "),s("ul",[s("li",[e._v("BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；")]),e._v(" "),s("li",[e._v("HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；")]),e._v(" "),s("li",[e._v("GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；")]),e._v(" "),s("li",[e._v("Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。")])]),e._v(" "),s("h2",{attrs:{id:"redis线程模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis线程模型"}},[e._v("#")]),e._v(" Redis线程模型")]),e._v(" "),s("h3",{attrs:{id:"redis是单线程吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis是单线程吗"}},[e._v("#")]),e._v(" Redis是单线程吗？")]),e._v(" "),s("p",[s("strong",[e._v("Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的")]),e._v("，这也是我们常说 Redis 是单线程的原因。")]),e._v(" "),s("p",[e._v("但是，"),s("strong",[e._v("Redis 程序并不是单线程的")]),e._v("，Redis 在启动的时候，是会"),s("strong",[e._v("启动后台线程")]),e._v("（BIO）的：")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Redis 在 2.6 版本")]),e._v("，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；")]),e._v(" "),s("li",[s("strong",[e._v("Redis 在 4.0 版本之后")]),e._v("，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。")])]),e._v(" "),s("p",[e._v("之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。")]),e._v(" "),s("p",[e._v("后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1f6b7d1d824bc4acaf04bfc4f965d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1282&h=834&s=293372&e=png&b=fefcfc",alt:"image.png"}})]),e._v(" "),s("p",[e._v("关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：")]),e._v(" "),s("ul",[s("li",[e._v("BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；")]),e._v(" "),s("li",[e._v("BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，")]),e._v(" "),s("li",[e._v("BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；")])]),e._v(" "),s("h3",{attrs:{id:"redis单线程模式是怎样的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis单线程模式是怎样的"}},[e._v("#")]),e._v(" Redis单线程模式是怎样的？")]),e._v(" "),s("p",[e._v("Redis 6.0 版本之前的单线模式如下图：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f430803d69644baaeefbb5d5430291f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1622&h=1547&s=930025&e=png&b=cce5fe",alt:"image.png"}})]),e._v(" "),s("p",[e._v("图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I/O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：")]),e._v(" "),s("ul",[s("li",[e._v("首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket")]),e._v(" "),s("li",[e._v("然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；")]),e._v(" "),s("li",[e._v("然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。")])]),e._v(" "),s("p",[e._v("初始化完后，主线程就进入到一个"),s("strong",[e._v("事件循环函数")]),e._v("，主要会做以下事情：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("首先，先调用"),s("strong",[e._v("处理发送队列函数")]),e._v("，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。")])]),e._v(" "),s("li",[s("p",[e._v("接着，调用 epoll_wait 函数等待事件的到来：")]),e._v(" "),s("ul",[s("li",[e._v("如果是"),s("strong",[e._v("连接事件")]),e._v("到来，则会调用"),s("strong",[e._v("连接事件处理函数")]),e._v("，该函数会做这些事情：调用 accpet 获取已连接的 socket -> 调用 epoll_ctl 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数；")]),e._v(" "),s("li",[e._v("如果是"),s("strong",[e._v("读事件")]),e._v("到来，则会调用"),s("strong",[e._v("读事件处理函数")]),e._v("，该函数会做这些事情：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；")]),e._v(" "),s("li",[e._v("如果是"),s("strong",[e._v("写事件")]),e._v("到来，则会调用"),s("strong",[e._v("写事件处理函数")]),e._v("，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。")])])])]),e._v(" "),s("h3",{attrs:{id:"redis-采用单线程为什么还这么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-采用单线程为什么还这么快"}},[e._v("#")]),e._v(" Redis 采用单线程为什么还这么快？")]),e._v(" "),s("p",[e._v("之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：")]),e._v(" "),s("ul",[s("li",[e._v("Redis 的大部分操作"),s("strong",[e._v("都在内存中完成")]),e._v("，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；")]),e._v(" "),s("li",[e._v("Redis 采用单线程模型可以"),s("strong",[e._v("避免了多线程之间的竞争")]),e._v("，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。")]),e._v(" "),s("li",[e._v("Redis 采用了 "),s("strong",[e._v("I/O 多路复用机制")]),e._v("处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。")])]),e._v(" "),s("h2",{attrs:{id:"redis持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[e._v("#")]),e._v(" Redis持久化")]),e._v(" "),s("h3",{attrs:{id:"redis-如何实现数据不丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-如何实现数据不丢失"}},[e._v("#")]),e._v(" Redis 如何实现数据不丢失？")]),e._v(" "),s("p",[e._v("Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。")]),e._v(" "),s("p",[e._v("Redis 共有三种数据持久化的方式：")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("AOF 日志")]),e._v("：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；")]),e._v(" "),s("li",[s("strong",[e._v("RDB 快照")]),e._v("：将某一时刻的内存数据，以二进制的方式写入磁盘；")]),e._v(" "),s("li",[s("strong",[e._v("混合持久化方式")]),e._v("：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；")])])])}),[],!1,null,null,null);s.default=i.exports}}]);